## Action-Sequence 业务代码说明（不含框架）

本说明面向该项目的“业务代码”层，不涉及任何外部或自研框架细节。重点解释帧驱动的动作序列、数据模型、播放引擎与场景组件如何协同工作。

### 目录

- 概览
- 架构与数据流
- 起步建议（Mono vs 非 Mono）
- 核心时序与帧驱动
- 数据模型：ActionClipData
- 播放引擎（纯逻辑）：ActionSequencePlayer
- 场景组件层
  - ActionStancePlayer
  - MultiStanceController
  - SimpleActionPlayer
  - PlayerController
- 启动与帧率配置
- 典型业务流程（从输入到命中）
- 演示序列时间线（示例）
- 扩展与改造建议
- 参数与调优要点
- 开发注意事项
- 文件与职责一览

## 概览

项目采用“固定逻辑帧”驱动的动作系统：以 60fps 的节拍推进动作序列，序列由若干“片段”组成（前摇/生效/后摇）。播放引擎在指定帧触发事件（位移冲量、命中窗口开关等），场景侧组件接收事件并驱动物体变换与可视化。

## 架构与数据流

- **时钟层**：`ActionFrameClock` 以固定步长发布 `OnTick` 事件，保证逻辑按 60fps 推进，并在过载时限制追帧，避免“螺旋死锁”。
- **锁与输入门控**：`ActionLock` 以计数方式控制“动作期间禁止移动”。动作开始 Acquire，结束 Release；`PlayerController` 依据锁位阻止移动输入。
- **数据层**：`ActionClipData` 定义每个片段的帧段、位移冲量与命中范围等参数，序列即该数据的列表。
- **播放引擎**：`ActionSequencePlayer` 为纯逻辑类，维护索引与帧计数，按规则发布事件，不直接操作 `Transform`。
- **场景组件层**：`ActionStancePlayer`、`MultiStanceController` 等组件订阅时钟与引擎事件，在场景中操控角色、绘制 Gizmos，并处理输入与姿态切换。

## 起步建议（Mono vs 非 Mono）
- 核心业务尽量用“非 Mono 的纯逻辑类”（可测试、解耦），通过事件/回调对外发布效果。
- 仅在需要与场景交互、接收输入或展示 Inspector 参数时，使用极薄的 Mono 适配层（如 `ActionStancePlayer`）。
- 需要序列化的数据优先考虑 `ScriptableObject` 或自定义数据容器，再由 Mono 读入并传给纯逻辑层；避免把复杂业务状态放在 Mono 上。
- 起步阶段的经验法则：
  - 逻辑=纯类；表现/输入=Mono 包装。
  - 先保证逻辑自洽与事件契约稳定，再逐步增加场景侧适配与可视化。

## 核心时序与帧驱动（ActionFrameClock）

- 以常量 `FramesPerSecond = 60` 与步长 `Step = 1/60` 运行。
- 使用 `accumulator` 累积 `Time.deltaTime`，每达到一个步长触发一次 `OnTick`。
- `MaxTicksPerFrame` 限制每帧最多追 4 个逻辑步，超限则丢弃剩余累积，避免过载导致的卡死。
- 订阅者：动作系统/角色组件等（例如姿态播放器）。

## 数据模型：ActionClipData

字段要点（按 Inspector 显示顺序）：

- **id**：片段标识，便于调试定位。
- **type**：`Move / Attack / Wait` 三类，语义不同：
  - Move：位移类片段，常配合“瞬移帧+冲量”。
  - Attack：攻击类片段，命中窗口等于“生效阶段”。
  - Wait：停顿/占位类片段。
- **startupFrames / activeFrames / recoveryFrames**：前摇/生效/后摇帧数，合计为片段总帧数。
- **impulseFrame**：在指定帧触发一次位移冲量（-1 表示不触发）。
- **moveImpulseX / moveImpulseY**：位移冲量，播放端通过事件驱动 `Transform` 平移。
- **damage**：攻击伤害值（业务钩子，当前示例未内置结算）。
- **hitOffset / hitRadius**：命中范围（以角色位置为圆心偏移+半径），用于可视化或后续命中检测。

## 播放引擎（纯逻辑）：ActionSequencePlayer

职责与行为：

- 维护序列、当前片段索引与片段内帧计数（`_clipIndex / _frameInClip`）。
- 在 `Tick()` 内：
  - 当 `_frameInClip == impulseFrame` 且冲量非零时，触发 `OnImpulseApplied(Vector2)`。
  - 若 `type == Attack` 且帧处于 `[startup, startup+active)`，打开命中窗口（`OnHitWindowStarted/Ended`）。
  - 帧计数达到片段总帧数后，发出 `OnClipEnded`，并进入下一个片段；序列完结时发出 `OnSequenceEnded` 并停止。
- 暴露事件而不直接操作场景对象，实现“数据驱动 + 逻辑与表现解耦”。


事件清单（外部订阅）：

- `OnClipStarted(ActionClipData, index)` / `OnClipEnded(ActionClipData, index)`
- `OnSequenceEnded()`
- `OnImpulseApplied(Vector2)`
- `OnHitWindowStarted()` / `OnHitWindowEnded()`

## 场景组件层

### ActionStancePlayer（姿态播放器）

- 订阅 `ActionFrameClock.OnTick`，以 60fps 推进 `ActionSequencePlayer.Tick()`。
- 按键触发（默认 `Mouse0 / Space`）后：
  - `ActionLock.Acquire()` 锁定移动；
  - 创建/重置 `ActionSequencePlayer`，订阅其事件；
  - 调用 `player.Start(sequence)` 播放当前姿态序列。
- 事件响应：
  - `OnImpulseApplied`：对 `transform.position` 施加位移；
  - `OnHitWindowStarted/Ended`：维护本地 `hitActive` 状态用于可视化；
  - `OnSequenceEnded`：关闭命中、`ActionLock.Release()` 释放移动锁。
- Gizmos：在命中窗口开启且存在当前片段时绘制命中范围线框。
 - 其他：
  - `ForceStopAndReleaseLockForSwitch()`：切换时停止并释放锁；
  - `AssignSequence(List<ActionClipData>)`：切换姿态时注入新序列。

 

### MultiStanceController（多姿态管理）

- 维护多个 `StanceConfig { name, sequence, hotkey }`。
- 支持按键切换（默认 `Alpha1..Alpha4`，也可在配置里自定义）。
 - 切换流程：
   1) `owner.ForceStopAndReleaseLockForSwitch()` 终止本体播放与移动锁；
   2) `AssignSequence()` 应用新姿态序列；
   3) 给本体一个向后斜上的位移（`switchLeap`）。

### SimpleActionPlayer（演示）

- 继承 `ActionStancePlayer`，在 `Reset()` 中填充一组演示用的序列（便于开箱即用的测试）。

### PlayerController（移动控制）

- 基础水平移动（A/D）。当 `ActionLock.IsLocked == true` 时忽略移动输入。

## 启动与帧率配置

- `MainLauncher` 在启动时设置渲染目标为 60fps（`Application.targetFrameRate=60`）并同步 `Time.fixedDeltaTime=1/60`。这与 `ActionFrameClock` 的 60fps 逻辑帧一致，便于测试与表现对齐。

## 典型业务流程（从输入到命中）

1) 玩家按下触发键 → `ActionStancePlayer.StartSequence()`
2) Acquire 移动锁 → 创建并启动 `ActionSequencePlayer`
3) `ActionFrameClock.OnTick` 以 60fps 调用 `player.Tick()`
4) 在 `impulseFrame` 触发位移事件 → 组件将冲量应用到 `transform`
5) 当帧处于攻击片段的“生效阶段” → 开启命中窗口（可用于后续命中检测）
6) 片段结束自动切至下一个；序列结束 → 释放移动锁

## 演示序列时间线（示例：SimpleActionPlayer）

- `clip.step`：Move，前摇8/生效0/后摇2，总10帧；第0帧触发位移冲量（例如 X=2.5）。
- `clip.slash`：Attack，前摇6/生效4/后摇8，总18帧；命中窗口=帧6~9。
- `clip.wait`：Wait，前摇6/生效0/后摇0，总6帧。
- 合计时长：10 + 18 + 6 = 34 帧（约 0.567 秒 @60fps）。

## 扩展与改造建议

- 新增片段类型：例如 Buff、投射物生成、受击硬直等；在 `ActionSequencePlayer.Tick()` 内按类型发布新的业务事件。
- 命中结算：在 `OnHitWindowStarted` 期间由外部系统执行“范围检测+伤害计算”。
- 位移曲线：将单帧冲量扩展为多帧速度曲线或曲线采样。
- 动画/特效对接：订阅 `OnClipStarted/Ended` 或基于帧号的回调，驱动动画层与特效系统。


## 参数与调优要点

- `FramesPerSecond / Step`：保证时钟与表现一致；必要时允许下调 MaxTicks 以稳态运行。
- `MaxTicksPerFrame`：限制追帧上限，防止过载；过多丢帧会影响逻辑精度。
- `impulseFrame / moveImpulse`：注意单位与方向（世界坐标平移），常配合地形/碰撞系统。
- `hitRadius / hitOffset`：用于可视化与检测，半径建议>0，偏移基于角色前向设定更合理（后续可扩展）。
- 帧数为非负：`activeFrames/recoveryFrames` 建议做非负约束，避免总帧数为负。

## 开发注意事项

- 事件订阅/反订阅要成对，避免悬挂引用（`OnEnable/OnDisable`、`OnDestroy`）。
- `ActionLock.Acquire/Release` 要严格配对；切姿态时使用 `ForceStopAndReleaseLockForSwitch()`。
- Gizmos 仅用于调试。
- 播放逻辑不触碰场景对象，所有副作用通过事件交由组件处理，方便测试与复用。

## 文件与职责一览

- `ActionFrameClock.cs`：全局 60fps 逻辑时钟（事件源，追帧防护）。
- `ActionLock.cs`：全局动作锁（计数式）。
- `Core/ActionSequencePlayer.cs`：播放引擎（纯逻辑与事件）。
- `Data/ActionClipData.cs`：片段数据模型。
- `Mono/ActionStancePlayer.cs`：姿态播放器（输入、锁、事件与 Gizmos）。
- `Mono/MultiStanceController.cs`：多姿态管理（切换、位移）。
- `SimpleActionPlayer.cs`：演示用姿态播放器（默认序列）。
- `PlayerController.cs`：移动控制（受 `ActionLock` 门控）。
- `Launcher/MainLauncher.cs`：启动帧率配置（60fps）。
